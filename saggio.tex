	\documentclass[12pt]{article}
	\usepackage{hyperref}
	\usepackage{graphicx}
	\usepackage[T1]{fontenc}
	\usepackage[utf8]{inputenc}
	\usepackage{color}
	\usepackage[font=small,labelfont=bf]{caption}
	\usepackage[english]{babel}
	\usepackage{datetime}
	\usepackage{listings}
	\usepackage{fancyhdr}
	\usepackage{lastpage}
	\usepackage{float}
	\pagestyle{fancy}
	\fancyhf{}
	\usepackage{listings}
	\usepackage{color}
	\definecolor{lightgray}{rgb}{.9,.9,.9}
	\definecolor{darkgray}{rgb}{.4,.4,.4}
	\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
	
	\lstdefinelanguage{JavaScript}{
		keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
		keywordstyle=\color{blue}\bfseries,
		ndkeywords={class, export, boolean, throw, implements, import, this},
		ndkeywordstyle=\color{darkgray}\bfseries,
		identifierstyle=\color{black},
		sensitive=false,
		comment=[l]{//},
		morecomment=[s]{/*}{*/},
		commentstyle=\color{purple}\ttfamily,
		stringstyle=\color{red}\ttfamily,
		morestring=[b]',
		morestring=[b]"
	}
	
	\lstset{
		language=JavaScript,
		backgroundcolor=\color{lightgray},
		extendedchars=true,
		basicstyle=\footnotesize\ttfamily,
		showstringspaces=false,
		showspaces=false,
		numbers=none,
		numberstyle=\footnotesize,
		numbersep=9pt,
		tabsize=2,
		breaklines=true,
		showtabs=false,
		captionpos=b
	}
	
	\addtolength{\oddsidemargin}{-2.4cm}
	\addtolength{\evensidemargin}{-3cm}
	\addtolength{\textwidth}{5cm}
	\addtolength{\topmargin}{-3cm}
	\addtolength{\textheight}{5cm}
	\usepackage{multicol}
	\newcommand\textline[4][t]{%
		\par\smallskip\noindent\parbox[#1]{.333\textwidth}{\raggedright\texttt{}#2}%
		\parbox[#1]{.333\textwidth}{\centering#3}%
		\parbox[#1]{.333\textwidth}{\raggedleft\texttt{#4}}\par\smallskip%
	}
	\rfoot{\textline[t]{}{Page \thepage \hspace{1pt} of \pageref{LastPage}}{}}
	\renewcommand{\today}{\thisdayofweekname\ \the\day\ \monthname\ \the\year}
	\title{Essay}
	\date{}
	\author{Trevisan Davide}
	\hypersetup{
		colorlinks=true,       % false: boxed links; true: colored links
		linkcolor=blue,          % color of internal links (change box color with linkbordercolor)
		citecolor=green,        % color of links to bibliography
		filecolor=blue,      % color of file links
		urlcolor=blue,
		filecolor=red,
		citecolor=blue,
	}
	\begin{document}
		\pagenumbering{arabic}
		
		
		
		\begin{titlepage}
			
			\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here
			
			\center % Center everything on the page
			
			%----------------------------------------------------------------------------------------
			%	HEADING SECTIONS
			%----------------------------------------------------------------------------------------
			
			\textsc{\LARGE University of Padova}\\[1.5cm] % Name of your university/college
			\textsc{\Large Computer and Network Security}\\[0.5cm] % Major heading such as course name
			
			%----------------------------------------------------------------------------------------
			%	TITLE SECTION
			%----------------------------------------------------------------------------------------
			
			\HRule \\[0.4cm]
			{ \huge insert-title-here}\\[0.3cm]
			 %TODO insert title 
			%Title of your document
			\HRule \\[1.5cm]
			
			%----------------------------------------------------------------------------------------
			%	AUTHOR SECTION
			%----------------------------------------------------------------------------------------
			
			\begin{minipage}{0.4\textwidth}
				\begin{flushleft} \large
					\emph{Students:}\\
					Davide Trevisan\\ % Your name
					Andrea Multineddu\\
				\end{flushleft}
			\end{minipage}
			~
			\begin{minipage}{0.4\textwidth}
				\begin{flushright}\large
					\emph{Registration number:} \\
					\textsc{1070686}\\ % matricola
					\textsc{1049261}\\
				\end{flushright}
			\end{minipage}\\[1cm]
			
			%----------------------------------------------------------------------------------------
			%	DATE SECTION
			%----------------------------------------------------------------------------------------
			
			{\large \today}\\[1cm] % Date, change the \today to a set date if you want to be precise
			
			%----------------------------------------------------------------------------------------
			%	LOGO SECTION
			%----------------------------------------------------------------------------------------
			
			\includegraphics[scale=0.35]{Logo.png} % Include a department/university logo - this will require the graphicx package
			
			%----------------------------------------------------------------------------------------
			
			\vfill % Fill the rest of the page with whitespace
		\end{titlepage}
		
		\newpage

\begin{multicols}{2}
	\section*{Introduction}
	Nowadays the majority of browsers let users the possibility of customizing it in order to get a new feature o a new style of visualization to better match the taste of the single user.
	All of this is achievable through the existing extensions for modern browsers. But there is also the opposite situation in which a malicious user tries to get personal information using this extensions.
	
	\section*{Abstract}
	Google Chrome browser is known for it huge ammount of extensions that let users do almost everything they want, but there also malicious extensions that aim to steal personal information about the life, bank accounts and every other single piece of information of the users. In this paper we presents 3 extensions: ChromeLogger\cite{ChromeLogger}, Stealth Screenshot e Activity Logger;\\ \\
	ChromeLogger is a keylogger and form grabber for Google Chrome that runs as an extension.	
	ChromeLogger works by injecting javascript into all loaded web pages.\\ \\
	Stealth Screenshot make screenshots of the active tab based on a timer and keep them until every opened tab is closed. Users can access with a combination of key to all screenshots taken during the session.\\ \\
	Activity Logger keep trace of all events related to extension and save them in Chrome storage. Users can check if there are installation, uninstallation, activation or deactivation of Chrome extension due to malicious code running in background.
\section*{How Chrome Extension works}
\subsection*{Background}
\subsubsection*{where to find an extension}
The Chrome Web Store is the official way for users
to find and install extensions, where the developers can publish it. They can also push out updates without any action
by the end-user.
In addition to the Chrome Web Store, extensions can
also be installed manually by a user or an external program.
Extension that are not downloaded through the official channel are flagged by Chrome when it starts	and the user is asked to disable them.
However, the user can whitelist the extension through the console.
\subsubsection*{Manually install an extension}
	Once you have all the source code of an extension in a folder, go to  \textsc{chrome://extensions} (or find it in the menu in more tools > extensions), then activate the developer mode on the top right of the page. To install the extension, you just have to indicate where is this folder on your computer clicking on load unpacked extention. For \textsc{.crx} packaged extension, you have to drag them on the \textsc{chrome://extensions} tab and then confirm that you want to install it (it's not directly possible because of the stronger security policy of chrome)
\subsection*{Permission}
Chrome requires extensions to list the
permissions needed to access the different parts of the
extension API. The complete list of the permissions and their interaction can be found on google developer page\cite{Google}.\\
Extensions must also specify a list of content scripts to indicate
JavaScript files that will run inside of the web page, because this is a powerful feature that allows an extension to be indistinguishable to the webpage behaviour. Besides the content scripts that
allow an extension to interact with a given page,
Chrome also allows extensions to run scripts in a
“background page” that often contain the
logic and state an extension needs for the entirety
of the browser session and do not have any visibility
to the user.\\
For example this is the manifest of the stealth screenshot extension:
\begin{lstlisting}
{
"name": "Stealth Screenshot Extension",
"version": "0.1",
"description": "This is a prototype
 of a background screenshot extension",
"background": {
"persistent": true,
"scripts": ["background.js"]
},
"commands": {
"toggle": {
"suggested_key": {
"windows": "Ctrl+Shift+Y",
"mac": "Command+Shift+Y",
"chromeos": "Ctrl+Shift+U",
"linux": "Ctrl+Shift+J"
},
"description": "My description"
}
},
"browser_action": {
"default_icon": "camera.png",
"default_title": "Take a screen shot!"
},
"omnibox": { "keyword" : "show" },
"permissions": [
"storage",
"tabs",
"<all_urls>",
"unlimitedStorage",
"activeTab"
],
"manifest_version": 2
}
\end{lstlisting}
as you can see, an extension has to declare in addition to all the permissions and all the interaction it has with the user such as an input in the omnibox or the click on the icon.
\section*{ChromeLogger}
\subsection*{Scope of the extension}
The extension is a form grabber for Google Chrome running natively in it without the need to install additional external software. It works on every loaded web pages acting on every form in the pages.
The extension manage to let the user checks for every submitted form all the keystroke done and some additional data about the time of submission. This is done by and additional page where we can turn on some additional option for the form grabber and visualize all the data collected by the extension.
The extension makes use of the following permissions in the manifest file:
\begin{itemize}
	\item  <all\_urls>
	\item  tabs
	\item  storage
	\item  unlimitedStorage
\end{itemize}
\subsection*{How the extension work}
When a web page is completely loaded ChromeLogger injects javascript it. The payload records keypresses using event listeners and saves them to Chrome's storage. Unlike other browser keyloggers, ChromeLogger runs natively in Chrome (on all OS's) without the need to install additional software.
The form grabber works in a similar way. Javascript is injected and event listeners are added for all forms. When a form is submitted, its data is saved to ChromeLogger's storage. This allows form data transferred over SSL to be saved in plaintext.
ChromeLogger's payload is written in pure JS and the log viewer is built using AngularJS. When a form is submitted, its data is saved to ChromeLogger's storage with the add of url and time data about the submission of the form.
The user has also access to an option page where he can turn on or off some optional features and check all the logs inside a table where can filtering and ordering them by the data and url.
\subsubsection*{Injection}
The injection is simple but effective:
\begin{lstlisting}
chrome.tabs.onUpdated.addListener(function(tabId, changeInfo) {
if (changeInfo.status === 'complete') {
chrome.tabs.executeScript(tabId, {
allFrames: true, 
file: 'src/inject/payload.js'
});
}
});
\end{lstlisting}
this allows the extension to add to the standard javascript of the page a malign javascript that allows the extention to receive and save all the form submitted by user and also the messagge submitted through social apps (for example whatsapp web)
\subsubsection*{Performance}
There aren't expensive operations or recursive function calls that requires a lot of computation so we can state that the impact on the CPU is negligible.
\section*{Activity Logger Extension}

\subsection*{Scope of the extension}

The extension aims to keep traces about the activities of other extensions and let the user know
about them through a dedicate page in which can check for every extension that are installed on the
Chrome browser. This logger keep traces of logs even if some extensions are unistalled. \\
The extension makes use of the following permission in the manifest file:
\begin{itemize}
	\item  management
	\item  storage
	\item  unlimitedStorage
\end{itemize}
\subsection*{How the extension work}
The extension at the browser start check the list of installed extension and updates the logs list with the one missing from it.
After this first check and update we create listener for the events related to extensions which are: 
\begin{itemize}
	\item  chrome.management.onInstalled
	\item  chrome.management.onUninstalled
	\item  chrome.management.onEnabled
	\item  chrome.management.onDisabled
\end{itemize}
Every time the user or some malicious code install, uninstall, enable or disable an extension a log of the triggered event is saved in the specific event log for the specific extension in the chrome storage.
The computation time is defined by the computation time of the Chrome search in his storage.
\subsubsection*{Performance}
There aren't expensive operations or recursive function calls that requires a lot of computation so we can state that the impact on the CPU is negligible.
\subsection*{Limitations}
The main limitation to this extension can be reconducted to the limitation imposed by or absence of Chrome APIs.
At the moment we can just check the events described early in the paper, every other event defined in Chrome APIs and the presence or absence of listener for a specific event.
A better controll on browser activity could be achieved by adding APIs, for example that return the name of extension from which is running codes in response to a specific event.
\subsection*{Future work}
The final aims of this extension are to log every single activity of installed extensions and jasvacript scripts inside web pages in response to every event happening inside Chrome itself (like a modification inside the chrome storafe area) or the web pages visited by the user (the pression of a button) and let the user check these logs	in order to let users check some strange and unwanted activities caused by some malicious code. At this time, for what we have find out from our research on chrome API documentation we can just check if there is some code waiting a specific events that trigger it.
But this is also a double-edged weapon that can led to problems for privacy maintenance because let every user, capable of writing chrome extension the possibility to check every activity, but from the other hands let malicious users the possibility  on customizzable browsers to get knowledge about users routines, personal data and ad-hoc javascript code injection.
\section*{Stealth Screenshot Extension}
The source code of the extension we developed is downloadable \href{https://github.com/Trexy94/Stealth-screenshot}{here}
\subsection*{Scope of the extension}
the scope of the stealth screenshot extension is to create a small prototype of an extension that catch screenshot in a regular interval with the minimum possible user interaction and obviously giving it back.
\subsubsection*{Activation and screenshot collection}
The extension uses the relatively new tab APIs given by chrome too take screenshot.
The extension makes use of the following APIs:\begin{itemize}
	\item storage
	\item tabs
	\item <all\_urls>
	\item unlimited storage
	\item active tab
	\end{itemize}
	This is the core part of the extension:
	\begin{lstlisting}
var imglist=[];
.............................
// Listen for a click on the camera icon.
 On that click, take a screenshot.
chrome.browserAction.onClicked.addListener(function() {
chrome.windows.create({type: "popup",state:"minimized"})
interval=0;
while(interval<30000000)//print x times, where x is the number of milliseconds/milleseconds for screenshot
{
setTimeout(function(){Loop()},interval);    
interval=interval+60000;
}
});

function Loop (){
chrome.tabs.captureVisibleTab(function(screenshotUrl) {
imglist[index]=screenshotUrl;
chrome.storage.sync.set({"data" : new Date().toJSON()}, function() {
index++;
if (chrome.runtime.error) {
console.log("Runtime error.");
}
});      
}
);};
............................
	\end{lstlisting}
	 The extension works in a simple way: it triggers on a browser event, in this case the click on the icon of the extension, but there are other possibilities: we tested that there are no simple ways to take screenshot without no interaction, because the security policy of the API doesn't allow to take a scrrenshot without some kind of events, presuming that the user should be aware of what is happening; not triggering any event returns only null.
Once triggered, the extension schedule all the future screenshot through the Javascript setTimeout method: this allows to take screenshot for hours, with only the need for a click to start.
The screenshot are stored in an array visible to all the extention methods.
\subsubsection*{Screenshot retrival}
The screenshot can be collected in two ways in the wxtension we developed:
through a combination of key for retriving all screenshots (we programmed it on Ctrl+Shift+Y) or writing "show" in the omnibox, pressing "tab" and writing in the omnibox the number of screenshot to show (starting from the last one).
\subsubsection*{Performance}
We tested that the extension is able to take screenshot with a interval of 1 minute for more than 2 hours without losing any screenshot.
The application occupy less of 50MB of RAM for an hour of screenshots taken every minute. The impact on the CPU is negligible.
Screenshot retrival through the kay combo however can  crash chrome, although it never happened in our PC because of the great performance (we had an Intel i5 6400, with 8GB of DDR4 memory and SSD), but it got freezed for some seconds.
\subsection*{Limitations}
The major limitation of this extension is that the screenshot only lives until the extension is active: this implies that closing all the windows of chrome completely deletes the screenshot taken.
This is a consequence of how the API and the chrome sandbox works. We at the moment found no way to get around it, but we are pretty confident that is possible to save those screenshots, but for our lack of knowledge we are not able at the moment to demonstrate it.
\subsection*{Future work}
Possible future works will focus on find a way to save those screenshot.
The application should also be rewritten without the tab API, to avoid of the limitation of it.
Javascript inject the code for the screenshot or use it for simulate the right events should do the work, but the time and the train needed to do it made impossible for us to test it for this paper.
\section*{Conclusions}
\begin{figure}[H]
	\begin{center}
		\includegraphics[width=9cm]{permission.png}
		\caption{The top 10 permissions found in the manifest
			files for all extensions HULK ran. Extensions can include			
			more than one permission.}
	\end{center}
\end{figure}
All the solution we have presented in this paper makes use of the most used chrome permission, as already stated in the HULK paper\cite{HULK}
As shown in the screenshot extension, taking screenshot without user consensus should not be allowed to the API (just a popup should be enough). \\
All this 3 prototype of extensions aim to increase the sicurity of the user browsering around the web pages, logging the user and basic behaviour of the installed extension. The user can after check all what he has done in the current session helping him in being more conscious of the possible danger generated by malicious code running in background.
\begin{thebibliography}{3}
	\bibitem{Google}
	\emph{Google developer page: permissions:}
	\href{https://developer.chrome.com/extensions/declare_permissions}{https://developer.chrome.com/extensions/\\declare\_permissions}
	
	\bibitem{ChromeLogger}
	Eric Zhang,\\
	\emph{ChromeLogger},\\
A keylogger and form grabber for Google Chrome that runs as an extension.\\
\href{https://github.com/Xeroday/ChromeLogger}{ChromeLogger}\\
\href{https://www.ericzhang.me/projects/chromelogger/}{referring site}

\bibitem{HULK}
\emph{Hulk: Eliciting Malicious Behavior in Browser Extensions}\\
Alexandros Kapravelos, Chris Grier, Neha Chachra, Christopher Kruegel
Giovanni Vigna, Vern Paxson,
UC Santa Barbara,
UC Berkeley, 
UC San Diego and 
International Computer Science Institute\\
\emph{23rd USENIX Security Symposium.}\\
\href{https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-kapravelos.pdf}{Paper}\\

\end{thebibliography}
\end{multicols}
 
\end{document}
